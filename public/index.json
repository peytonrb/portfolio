
[{"content":"","externalUrl":null,"permalink":"/games/interweaver/player-mechanics/","section":"Games","summary":"","title":"Player Mechanics","type":"games"},{"content":"\rOverview\r#\rProject Burbank allowed the player to take the role of the Director in the campaign they played out during the game. Burbank uniquely allowed players to customize not just their Main Character and the narrative they were directing, but allowed them to edit a cast of characters\u0026rsquo; memories and backstories, change the genre of the story, and more systemic characteristics. I was responsible for the Pre- and Post-Game systems, ensured that they created an experience as engaging as the core gameplay, and they became integral parts of the gameplay loop as a result.\nThese systems were instrumental in establishing the core experience for the player and also ensured the game remained compelling for those who did not want to direct the entire experience. Both Pre- and Post-Game flows consisted of a series of stages containing a mix of UI and game camera that the player progressed through to set up and view the results of their campaign. These systems were built in C++ with Blueprint and required heavy use of MVVM, State Tree, TFutures and TPromises, and more.\nIn-Game Representation\r#\rPre-Game\r#\rThe Pre-Game flow was responsible for guiding the player through character and campaign customziations, and had Stages like Character Customization, Cast Customization, Campaign and Story Setup. It was essential that Pre-Game not only introduced players to all the system-defining customization options, but was also a creative outlet and fun in its own right.\nSome examples of Pre-Game Stages:\nPost-Game\r#\rThere are many unique and interesting ways to display game stats at the end of a campaign, which made designing this system even more fun. The Post-Game flow consisted of Studio Notes (our recap screen), Level Up, and the Next Scene Chooser. Because each playthrough was so interactive and unique to itself, it was important that we encapsulated the nuances of each playthrough in this flow.\nSome examples of Post-Game Stages:\nSystem Architecture\r#\rEach Stage of the Pre- and Post-Game flows were treated as individual entities, though they existed in the same world and were pre-loaded to avoid any additional buffer. A State Tree managed the entirety of the flow due to its modular nature, and each player-facing step was treated as a State. Each State followed the same general pattern: A custom C++ Manager Actor was spawned as it entered the State and gets assigned the associated UI\u0026rsquo;s View Model.\nThe Manager Actor and View Model manage the all of the gameplay logic and update the widget via bindings. The majority of the logic is kept in C++ to avoid checking out Assets in Perforce to maintain design and iteration speed.\nModular State Tree-Based Design\r#\rEach player-facing screen was treated as its own individual State, and each State was able to have unique children States that allowed us to further customize the internal functionality of each Stage. This was exceptionally important due to the asynchronous nature of the systems in a few Stages.\nPre-Game\nPost-Game\nIn Stages where the player is not able to progress until internal asynchronous background logic is processed, I utilized \u0026lsquo;In Progress\u0026rsquo; child stages to stop progression until the Manager Actor broadcasts a delegate to flag that all asynchronous processes have fully finished and it is safe to transition. This modular design also makes it easy to swap out or add in screens without editing any \u0026lsquo;Back\u0026rsquo; or \u0026lsquo;Next\u0026rsquo; functionality by hand.\nMVVM Patterns\r#\rTo manage the UI widgets per stage and the game state itself, I utilized MVVM to connect player-inputted data to internal gameplay systems to dynamically generate new narrative campaigns and to collect and record campaign state data in these two systems.\nBelow is an example of the View Model on the Character Creator Stage:\nSince the View Model references the Manager Actor and vice versa, making changes or running logic for the UI from C++ becomes very simple. View Models are heavily used on all Stages during these flows, and handled a variety of tasks from updating UI, processing player-inputted data, and customizing each individual playthrough. The base Manager Actor and View Model classes set this functionality up by default for ease of creating new Stages in the future.\nTFutures and TPromises\r#\rAsynchronous coding was heavily used during these flows because Stages were dependent on the information gained from the Stage prior - however not all necessary data was instantly transmitted or readable. This created a lot of complexity as I was designing the system and was the forcing function behind a few systemic decisions that were made.\nIt was especially common to require multiple Actors or specs that were created asynchronously during this process. Below I\u0026rsquo;ve attached a pseudocode snippet of a pattern I employed heavily to manage this requirement:\nTSharedPtr\u0026lt;TPromise\u0026lt;TArray\u0026lt;ACharacterActor*\u0026gt;\u0026gt;\u0026gt; Promise = MakeShared\u0026lt;TPromise\u0026lt;TArray\u0026lt;ACharacterActor*\u0026gt;\u0026gt;\u0026gt;(); TWeakObjectPtr\u0026lt;ACharacterActor\u0026gt; WeakSelf(this); CreateCharacterAsync().Next([WeakSelf, Promise](const TArray\u0026lt;FNewCharacterSpec\u0026gt;\u0026amp; CharacterSpecs)) --\u0026gt; void { if (!WeakSelf.IsValid()) { Promise-\u0026gt;EmplaceValue(TArray\u0026lt;ACharacterActor*\u0026gt;()); return; } TArray\u0026lt;TFuture\u0026lt;ACharacterActor*\u0026gt;\u0026gt; Futures; for (FInstancedStruct Spec : CharacterSpecs) { ... Futures.Add(CreateCharacterFromSpec(*Spec)); } WhenAll(MoveTemp(Futures)).Next([Promise](const TArray\u0026lt;ACharacterActor*\u0026gt;\u0026amp; Results) { Promise-\u0026gt;EmplaceValue(Results); }); }); return Promise-\u0026gt;GetFuture();\rWhere:\nTFuture\u0026lt;ACharacterActor*\u0026gt; CreateCharacterFromSpec(const FInstancedStruct\u0026amp; CharacterSpec);\rThis snippet is one instance of a broader pattern that I used throughout the system. Rather than letting async work leak into gameplay-facing systems, I chained async steps together and wrapped the result in a single return value, keeping other dependent and higher-level systems clean and latent. This made the base code easier to iterate on, safer under lifecycle or loading changes, and much easier to debug as the system grew.\n","externalUrl":null,"permalink":"/games/burbank/pre-post-game/","section":"Games","summary":"","title":"Pre- and Post-Game Flow","type":"games"},{"content":"\rOverview\r#\rProject Burbank is a storytelling platform for players to immerse themselves in any narrative imaginable - it takes players\u0026rsquo; decisions and alters the campaign at hand to create surprising, one-of-a-kind gameplay experiences. I supported this characteristic by creating a procedural interior decoration system that intakes information about the player\u0026rsquo;s campaign at runtime and filling subsequent Levels with contextually appropriate assets, while also maintaining navigable space and realistic orientations.\nThis system was not only instrumental in establishing the mood and feel of a Level in game, but it was also visually and mechanically obvious if there were any logical flaws. It also had to handle external systems like lighting, BP Actors in the Level, player-placed objects, cameras, and more. It was imperative that I ensured this system was able to handle not only our technical limitations, but also uplifted the player\u0026rsquo;s experience.\nKey Systems\r#\rProcedural Content Generation (PCG) World Partition \u0026amp; Data Layers Choosers (RandTable?) Schemas and Socket Actors In-Game Representation\r#\rEach Level is constructed at design-time with base 3D models as a greybox to outline the general shape and orientation of objects in space. Each Level in UE is constructed with a variety of Data Layers containing different Socket Actors to hold contextual data and act as a base in order to preserve character pathfinding and Actor Slot requirements. The Decoration system then reads the Socket Actors and the current campaign information and chooses assets to sort and where to place them accordingly.\nYou can see 2 base Layout examples from our Apartment Level below:\nAfter the Decoration system finishes placing assets on the determined base layout, the final in-game Level now contextually fits the unique story being played out and also furthers player immersion:\nTechnical Spec\r#\rBelow I\u0026rsquo;ve condensed the official Technical Design Document I wrote for this system to give an idea of how the system worked.\n","externalUrl":null,"permalink":"/games/burbank/set-deco/","section":"Games","summary":"","title":"Procedural Interior Decoration","type":"games"},{"content":"","externalUrl":null,"permalink":"/games/interweaver/puzzles/","section":"Games","summary":"","title":"Puzzles","type":"games"},{"content":"\rOverview\r#\rIn-Game Representation\r#\rSystem Architecture\r#\rRelationship Editor and Tools\r#\r","externalUrl":null,"permalink":"/games/burbank/relationships/","section":"Games","summary":"","title":"Relationships and Character Memories","type":"games"},{"content":"","externalUrl":null,"permalink":"/games/interweaver/shaders-vfx/","section":"Games","summary":"","title":"Shaders and VFX","type":"games"},{"content":"","externalUrl":null,"permalink":"/games/burbank/slate-ui/","section":"Games","summary":"","title":"Slate Tooling","type":"games"},{"content":"Below are games that I have worked on professionally, academically, and personally. These are games in which I have created and owned systems that shipped with the final product and were instrumental in both production and deployment. All content featured is original work that I own and am authorized to share.\nClick below to view showcases, technical design documents, system designs, and more.\n","date":"1 May 2025","externalUrl":null,"permalink":"/games/","section":"Games","summary":"","title":"Games","type":"games"},{"content":"","date":"1 May 2025","externalUrl":null,"permalink":"/","section":"Peyton Bischof","summary":"","title":"Peyton Bischof","type":"page"},{"content":"\rGameplay Engineer\r#\rProject Burbank is an unreleased life sim developed by a small team of industry veterans in Unreal Engine 5 at Midsummer Studios in Hunt Valley, MD. Burbank uniquely explores player connection with characters and storylines through life sim/visual novel sandbox-style gameplay. I am responsible for several core systems and have a hand in nearly every feature of the game.\nThis project was unique in its timeframe - we rapidly designed, engineered, and iterated on all systems and pipelines to meet tight demo deadlines. As a result, as well as creating gameplay mechanics in C++ and Blueprint, I also became fluent in Slate to customize our Editor and tooling to support our designers as we rapidly iterated on the games\u0026rsquo; development.\nDevelopment Log\r#\rDue to the small team size of 13, my skills were leveraged in a variety of ways to support all aspects of the game. Below are some of the major systems and features I contributed to Project Burbank:\n","date":"1 May 2025","externalUrl":null,"permalink":"/games/burbank/","section":"Games","summary":"","title":"Project Burbank","type":"games"},{"content":"\rCreative Director, Gameplay Programmer, Lead Technical Artist\r#\rInterweaver is an isometric puzzle-platformer built in Unity by a small team of students from the University of Central Florida as our Senior Design Capstone. I served as the Creative Director and was also responsible for programming a variety of major systems and mechanics in C# and created the majority of the visual effects in Unity\u0026rsquo;s Shader and VFX Graph.\nThis was my first experience leading a full development team of designers, artists, and programmers. I was at the forefront of production and development, and formed a leadership team that quickly became comfortable with Agile development strategies to create the best player experience during our 35-week production period.\nYou can find the Steam page here.\nDevelopment Log\r#\rI contributed heavily to this project from all aspects of production: code, art, and design. Below I will go into depth on major systems, features, and effects I am responsible for, as well as trying to explain some design decisions and philosophies that I learned during this experience.\n","date":"20 May 2024","externalUrl":null,"permalink":"/games/interweaver/","section":"Games","summary":"","title":"Interweaver","type":"games"},{"content":"","externalUrl":null,"permalink":"/contact/","section":"Peyton Bischof","summary":"","title":"About","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/resume/","section":"Peyton Bischof","summary":"","title":"Resume","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]