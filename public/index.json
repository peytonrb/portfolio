
[{"content":"\rOverview\r#\r","externalUrl":null,"permalink":"/games/interweaver/player-mechanics/","section":"Games","summary":"","title":"Player Mechanics","type":"games"},{"content":"\rOverview\r#\rProject Burbank allowed the player to take the role of the Director in the campaign they played out during the game. Burbank uniquely allowed players to customize not just their Main Character and the narrative they were directing, but allowed them to edit a cast of characters\u0026rsquo; memories and backstories, change the genre of the story, and more systemic characteristics. I was responsible for the Pre- and Post-Game systems, ensured that they created an experience as engaging as the core gameplay, and they became integral parts of the gameplay loop as a result.\nThese systems were instrumental in establishing the core experience for the player and also ensured the game remained compelling for those who did not want to direct the entire experience. Both Pre- and Post-Game flows consisted of a series of stages containing a mix of UI and game camera that the player progressed through to set up and view the results of their campaign. These systems were built in C++ with Blueprint and required heavy use of MVVM, State Tree, TFutures and TPromises, and more.\nIn-Game Representation\r#\rPre-Game\r#\rThe Pre-Game flow was responsible for guiding the player through character and campaign customziations, and had Stages like Character Customization, Cast Customization, Campaign and Story Setup. It was essential that Pre-Game not only introduced players to all the system-defining customization options, but was also a creative outlet and fun in its own right.\nSome examples of Pre-Game Stages:\nPost-Game\r#\rThere are many unique and interesting ways to display game stats at the end of a campaign, which made designing this system even more fun. The Post-Game flow consisted of Studio Notes (our recap screen), Level Up, and the Next Scene Chooser. Because each playthrough was so interactive and unique to itself, it was important that we encapsulated the nuances of each playthrough in this flow.\nSome examples of Post-Game Stages:\nSystem Architecture\r#\rEach Stage of the Pre- and Post-Game flows were treated as individual entities, though they existed in the same world and were pre-loaded to avoid any additional buffer. A State Tree managed the entirety of the flow due to its modular nature, and each player-facing step was treated as a State. Each State followed the same general pattern: A custom C++ Manager Actor was spawned as it entered the State and gets assigned the associated UI\u0026rsquo;s View Model.\nThe Manager Actor and View Model manage the all of the gameplay logic and update the widget via bindings. The majority of the logic is kept in C++ to avoid checking out Assets in Perforce to maintain design and iteration speed.\nModular State Tree-Based Design\r#\rEach player-facing screen was treated as its own individual State, and each State was able to have unique children States that allowed us to further customize the internal functionality of each Stage. This was exceptionally important due to the asynchronous nature of the systems in a few Stages.\nPre-Game\nPost-Game\nIn Stages where the player is not able to progress until internal asynchronous background logic is processed, I utilized \u0026lsquo;In Progress\u0026rsquo; child stages to stop progression until the Manager Actor broadcasts a delegate to flag that all asynchronous processes have fully finished and it is safe to transition. This modular design also makes it easy to swap out or add in screens without editing any \u0026lsquo;Back\u0026rsquo; or \u0026lsquo;Next\u0026rsquo; functionality by hand.\nMVVM Patterns\r#\rTo manage the UI widgets per stage and the game state itself, I utilized MVVM to connect player-inputted data to internal gameplay systems to dynamically generate new narrative campaigns and to collect and record campaign state data in these two systems.\nBelow is an example of the View Model on the Character Creator Stage:\nSince the View Model references the Manager Actor and vice versa, making changes or running logic for the UI from C++ becomes very simple. View Models are heavily used on all Stages during these flows, and handled a variety of tasks from updating UI, processing player-inputted data, and customizing each individual playthrough. The base Manager Actor and View Model classes set this functionality up by default for ease of creating new Stages in the future.\nTFutures and TPromises\r#\rAsynchronous coding was heavily used during these flows because Stages were dependent on the information gained from the Stage prior - however not all necessary data was instantly transmitted or readable. This created a lot of complexity as I was designing the system and was the forcing function behind a few systemic decisions that were made.\nIt was especially common to require multiple Actors or specs that were created asynchronously during this process. Below I\u0026rsquo;ve attached a pseudocode snippet of a pattern I employed heavily to manage this requirement:\nTSharedPtr\u0026lt;TPromise\u0026lt;TArray\u0026lt;ACharacterActor*\u0026gt;\u0026gt;\u0026gt; Promise = MakeShared\u0026lt;TPromise\u0026lt;TArray\u0026lt;ACharacterActor*\u0026gt;\u0026gt;\u0026gt;(); TWeakObjectPtr\u0026lt;ACharacterActor\u0026gt; WeakSelf(this); CreateCharacterAsync().Next([WeakSelf, Promise](const TArray\u0026lt;FNewCharacterSpec\u0026gt;\u0026amp; CharacterSpecs)) --\u0026gt; void { if (!WeakSelf.IsValid()) { Promise-\u0026gt;EmplaceValue(TArray\u0026lt;ACharacterActor*\u0026gt;()); return; } TArray\u0026lt;TFuture\u0026lt;ACharacterActor*\u0026gt;\u0026gt; Futures; for (FInstancedStruct Spec : CharacterSpecs) { ... Futures.Add(CreateCharacterFromSpec(*Spec)); } WhenAll(MoveTemp(Futures)).Next([Promise](const TArray\u0026lt;ACharacterActor*\u0026gt;\u0026amp; Results) { Promise-\u0026gt;EmplaceValue(Results); }); }); return Promise-\u0026gt;GetFuture();\rWhere:\nTFuture\u0026lt;ACharacterActor*\u0026gt; CreateCharacterFromSpec(const FInstancedStruct\u0026amp; CharacterSpec);\rThis snippet is one instance of a broader pattern that I used throughout the system. Rather than letting async work leak into gameplay-facing systems, I chained async steps together and wrapped the result in a single return value, keeping other dependent and higher-level systems clean and latent. This made the base code easier to iterate on, safer under lifecycle or loading changes, and much easier to debug as the system grew.\nReflection\r#\r","externalUrl":null,"permalink":"/games/burbank/pre-post-game/","section":"Games","summary":"","title":"Pre- and Post-Game Flow","type":"games"},{"content":"\rOverview\r#\rProject Burbank is a storytelling platform for players to immerse themselves in any narrative imaginable - it takes players\u0026rsquo; decisions and alters the campaign at hand to create surprising, one-of-a-kind gameplay experiences. I supported this characteristic by creating a procedural interior decoration system that intakes information about the player\u0026rsquo;s campaign at runtime and filling subsequent Levels with contextually appropriate assets, while also maintaining navigable space and realistic orientations.\nThis system was not only instrumental in establishing the mood and feel of a Level in game, but it was also visually and mechanically obvious if there were any logical flaws. It also had to handle external systems like lighting, BP Actors in the Level, player-placed objects, cameras, and more. It was imperative that I ensured this system was able to handle not only our technical limitations, but also uplifted the player\u0026rsquo;s experience.\nThis system was built in C++ with Blueprint, and utilized World Partition, PCG, and more.\nIn-Game Representation\r#\rEach Level is constructed at design-time with base 3D models as a greybox to outline the general shape and orientation of objects in space. Each Level in UE is constructed with a variety of Data Layers containing different Socket Actors to hold contextual data and act as a base in order to preserve character pathfinding and Actor Slot requirements. The Decoration system then reads the Socket Actors and the current campaign information and chooses assets to sort and where to place them accordingly.\nYou can see 2 base Layout examples from our Apartment Level below:\nAfter the Decoration system finishes placing assets on the determined base layout, the final in-game Level now contextually fits the unique story being played out and also furthers player immersion:\nTechnical Spec\r#\rAs players progressed through their narrative campaigns, it was important that the Levels their characters spawned into visually complimented and matched the aesthetic of the story being played out. This procedural interior Level decoration system intakes data about the active Story, available Assets to populate the space, and more to produce an accurately dressed Level.\nBelow I\u0026rsquo;ve summarized the official Technical Design Document I wrote for this system to give an idea of how it worked.\nSummary\r#\rEach World Partition Level was built as a greyboxed space using templated Data Layers instead of fixed Assets. Designers constructed these Layers with Sockets, which were Assets embedded with metadata and natural language descriptions responsible for holding space for NavMesh and cinematic cameras. The Decoration system queried the Sockets in the space once it chose the most relevant Data Layer and populated them with Assets relevant to the runtime narrative. From there, designer and auto-placed Inclusion Volumes marked up where PCG spawns non-blocking decorative clutter, ensuring the space appeared engaging, immersive, and relevant to the story at the end.\nAll of this logic exists in a Plugin and includes an Editor Module for custom property, detail, and editor customizations to support designers as they construct each Level.\nCustom Classes\r#\rDecoDataLayer\nThe need for DecoDataLayers arose when I realized that a full procedually decorated interior space, also because the player is able to edit their space, would cause too much instability between character navigation, cinematic cameras, and more. DecoDataLayers are extended from the base DataLayerAsset class and are used to create all Data Layers that can be evaluated by the Decoration system.\nSome Properties include:\nA natural language FText description of the space and example use-cases Gameplay Tag container for relevant context tags DecoSocketComponent\nThe DecoSocketComponent was added in-editor to any Actor in a DecoDataLayer to greybox the space. This component dictates what Actors and what properties about them are swappable. These Components subscribe to policies that dictate what about the Actor they are on can be affected by the system. Example policies are:\nBlueprint: the entire BP Actor can be changed Static Mesh: the Mesh of the Actor can be changed Material: certain Materials can be changed Group: the Actor is changed exactly the same as another Socket These Components allowed us to build more modular Data Layers because we could nest Components with varying degrees of complexity for a more unique space each playthrough (ie. a Couch with a Material Component policy could be placed by the Deco system in an Component that allows BP subtitution). These Sockets are responsible for applying their own customizations once they are given narrative details by the DecoActor. It is also possible to override query behavior on Sockets for different Assets, so not all Sockets evaluate the Asset Libraries the same as well.\nSome Properties on the Socket Components include:\nThe policy to follow A natural language FText description of the expected object Gameplay Tag container for relevant context tags It is also important to note here that the Transforms and orientations of Assets is a major constraint here. To account for this, the Asset Libraries themselves reject Assets that would not fit in the expected Sockets to avoid hard-to-follow bugs down the line.\nDecoActor\nThe DecoActor is responsible for centralizing most of the logic pertaining to the Decoration System. A single DecoActor is spawned automatically the first time a Level is loaded into a Show for a particular interior Set at runtime. It is important to mention that a Level can get used for multiple different Set types (ie. the \u0026lsquo;Bedroom\u0026rsquo; level could get separate Decorations for \u0026lsquo;Character A\u0026rsquo;s Bedroom\u0026rsquo; and \u0026lsquo;Chararacter B\u0026rsquo;s Bedroom\u0026rsquo;). Therefore, one Level may have multiple different runtime occurences of DecoActors as the player progresses in their campaign.\nDecoActors handle the decoration of a Set when they get initialized and are also responsible for polishing existing Decorations as Sets are revisited. If the player revisits a Set with an existing DecoActor, a new one is not created and the existing one redecorates the room.\nSome other responsibilities include:\nMaintaining Sockets Querying Asset Libraries Activating proper Data Layers (including non-Deco Layers like Weather, etc.) Validate Decoration placements I also made it possible to subclass the DecoActor to customize behavior for different Level types. For example, the default Decoration logic did not satisfy outdoor Levels the way it did indoor Levels. Designers were able to configure what schema was followed during runtime. I also supported Editor-only testing by exposing DecoActor functionality to the editor, allowing designers to test the Decorations without needing to run the game.\nDecoVolume\nThis system heavily utilized Procedural Content Generation (PCG) to decorate the space once all navigation-blocking objects have been placed. I created custom DecoVolumes for designers and marked objects to spawn, and are the area in which PCG utilizes to decorate. These Volumes get sampled and their relevant PCG Graphs complete the final layer of decoration.\nDesigners can specify on the Volume which PCG Graphs will be used to decorate the space within. These Volumes respect existing Decorations, player-placed objects, and cameras. Multiple graphs can apply to each Volume, and a hierarchy of importance between graphs is established in order of appearance in the Property to determine which graph\u0026rsquo;s objects are prioritized.\nDecoLibrary\nWe utilized hierarchial, random containers built in-house similar to Unreal Choosers to store the Asset Libraries. These containers held entries that were able to be populated with the Assets and tag them with necessary metadata. Sockets queried these Libraries depending on what type of Asset they were expecting. These Libraries rejected Assets that fell outside Transform and Orientation requirements and also handled random choosing behavior.\nSystem Architecture\r#\rThere are two main processes that the Decoration system is responsible for: Decorating and Redecorating. The first time a Level is decorated is the most important, because Decorations persist as the Level gets reused in the same narrative, just updated.\nAssets are selected from the queried Libraries based on both runtime narrative context and the metadata provided by the populated Sockets. The Decoration system collects this context and passes the Socket and Asset descriptions through a proprietary embeddings subsystem, which produces similarity scores based on natural-language semantics. These scores are evaluated alongside structured metadata constraints to determine the best match for each Socket. The highest-scoring Assets are then utilized for the Sockets.\nAnother concept that I utilized heavily in this system is the idea of Pinned objects. We did not want the system to entirely redecorate a Level every time a player revisted it. However, as to real life, it also would not make sense for a space to stay identical after the campaign and time have continued to progress. The Decoration system is responsible for systematically Pinning objects that are determined as characteristic to the scene, and these Pinned objects will persist with the Set until the campaign has finished. Pinned objects often included:\nNavigation-Blocking Furniture Narrative-important Assets Characteristic decorative pieces Player-placed Assets Reflection\r#\rThis was a fairly involved and player-facing system, and I learned a lot from the work I did. Some of my main learnings:\npolicy based programming ensured everything was not dependent so we could just place and remove things as needed rejecting assets from tables early on before causing problems wsa good sockets allowed for multipass generation -\u0026gt; sockets with blueprint swap policies could then have their material swap activate making tagging assets so that it was esy for designers to support design intent while not over-constraining and limiting variation (natrual language embeddings helped solve for) PCG and its many uses ","externalUrl":null,"permalink":"/games/burbank/set-deco/","section":"Games","summary":"","title":"Procedural Interior Decoration","type":"games"},{"content":"\rOverview\r#\r","externalUrl":null,"permalink":"/games/interweaver/shaders-vfx/","section":"Games","summary":"","title":"Shaders and VFX","type":"games"},{"content":"\rOverview\r#\rCharacter relationships are at the core of Burbank - they drive the player to make gameplay decisions, explore parasocially, and are a vessel to experience some of Burbank\u0026rsquo;s most emotional moments. I was responsible for creating the base Relationship system that manages all 2-character relationships and the gameplay impact of the player character\u0026rsquo;s choices in-game. All characters started at a base \u0026lsquo;Acquaintance\u0026rsquo; Relationship, but were able to progress through a Map of possible relationships with any given NPC. Each Relationship affected the gameplay differently, and had different conditions to achieve.\nRelationship Design\r#\rAs we were designing how Relationships would manifest in the game, we closely examined how people communicate in real life to pinpoint the most exciting moments to play out through our game. This led us to our current design, which involves the player character navigating through a \u0026lsquo;Map\u0026rsquo; of different Relationship stages. All characters start at a default Acquaintance relationship, and depending on how the player interacts with other characters and the world around them, their relationships with individual characters can progress to different pre-prescribed Relationship Stages.\nA small snippet of the Relationship Map in which the player\u0026rsquo;s character could navigate:\nFor the player to change their character\u0026rsquo;s Relationship with any given character in the Level, they must meet specific criteria tied to the next Stage. Each Stage requires the Player to complete certain actions or gameplay decisions in order to move forward in their relationship. For example, if the Player successfully pulls off a riskier romantic advancement on another character, their Relationship could progress straight to Dating, rather than Flirting. This created more dynamic gameplay not just between playthroughs, but also created complex inter-character relationships in game that drew the Player themselves in.\nRelationship Stages were also associated with their own Gameplay Modifiers, Effects, and more. If the Player tried flirting with a character while actively in a Romantic relationship, other NPCs would react accordingly (for better or worse) and the Player receives gameplay buffs and debuffs depending on their runtime choices.\nSystem Architecture\r#\rRelationships systematically have 2 major components to them: a Relationship Data Asset and a Relationship State Actor. The team created the Data Assets during production, and they contributed to the systematic representation of the Relationship Map. Each Relationship pair has an owning State Actor, which is responsible for the involved characters and is the runtime representation of a Relationship. These State Actors keep track of which Relationship the two characters have at any given time and maintain a reference to the relevant Relationship Data Asset. The Properties defined by this Asset dictates this Relationship\u0026rsquo;s effect on the game.\nRelationship Data Asset\r#\rWe utilized custom Data Assets heavily throughout Burbank to store game states and the Relationship system is no different. The custom Relationship Asset I made is the systematic representation of a Relationship Stage, such as \u0026lsquo;Best Friend\u0026rsquo;, \u0026lsquo;Married\u0026rsquo;, \u0026lsquo;Rival\u0026rsquo;, etc.\nSome of this Asset\u0026rsquo;s Properties include:\nContext to be read during runtime for the involved characters Relationships that can be progressed to from this Relationship The criteria and gameplay requirements to progress this Relationship Effects and gameplay modifiers that occur when the Player character has this Relationship active The Relationship State Actor holds a reference to one Relationship Data Asset at a time. It reads the Asset\u0026rsquo;s Properties at runtime with gameplay context to determine how to progress throughout the Relationship Map.\nRelationship State Actor\r#\rRelationship State Actors are responsible for the relationship between 2 characters at runtime, and are created by the system automatically for all existing characters at a base \u0026lsquo;Acquaintance\u0026rsquo; relationship to start the game. They listen for game state events and delegates to trigger Relationship events as well as applying relevant modifiers and Game Effects to the campaign.\nThese State Actors were responsible for managing a variety of data at runtime efficiently and visually elegantly, such as:\nhandling asynchronous processes to ensure non-blocking gameplay tracking and managing a variety of game systems using modular design principles, ensuring flexibility as we continued to update system designs subscribed to the Event Bus system used throughout the game to listen for game events to facilitate clean communication across systems and reducing direct dependencies between systems integrating various game state delegates to handle gameplay interactions maintaining an Inventory system to cleanly track and manage the Player\u0026rsquo;s Relationship progression In-Game Representation\r#\rAs Players developed their characters\u0026rsquo; Relationships, they were able to unlock narrative and cinematic moments with the other participant. While the exact Relationship Map is not player-facing, a lot of progression criteria and other relationship state data is able to be viewed in the UI. Any information not immediately clear to the player could be deduced from interactions with characters that the Player character has relationships with passively via gameplay. Environment interactions and gameplay reactions to the player\u0026rsquo;s choices implicitly guided them towards narrative-rich interactions.\nMuch like how strengthening relationships in real life leads to more meaningful moments and impacts your day to day more, building stronger bonds with other characters unlock richer gameplay opportunities. Burbank\u0026rsquo;s characters had a dynamic memory system, allowing them to recall significant moments from the player\u0026rsquo;s campaign to help shape their relationships based on both the player\u0026rsquo;s intentional and passive choices throughout the world.\nReflection\r#\r[code reflection here]\n","externalUrl":null,"permalink":"/games/burbank/relationships/","section":"Games","summary":"","title":"Character Relationship System","type":"games"},{"content":"\rOverview\r#\r","externalUrl":null,"permalink":"/games/interweaver/puzzles/","section":"Games","summary":"","title":"Puzzles","type":"games"},{"content":"\rOverview\r#\r","externalUrl":null,"permalink":"/games/interweaver/concept/","section":"Games","summary":"","title":"Creative Vision \u0026 Concepts","type":"games"},{"content":"\rOverview\r#\rDue to our small team size and rapid iteration time, it was imperative we spent the least amount of time creating and organizing Assets in mass as we were building our Levels. To support this, I integrated creating gameplay systems with Slate tools and editors as part of my regular workflow to expedite the process of asset creation and setup. This was exemplified throughout the project but I will highlight bigger editors and tools below.\nRelationship Editor\r#\rOne of the most utilized editors I created for Project Burbank is the Relationship Editor and related tools. The need for this editor arose when we were building out the Relationship Map, and it became hard to keep track of how the various Relationships were able to progress. We needed a way for our designers to visualize how each Stage of the Relationship Map was able to evolve and easily compare the effects and constraints of them all.\nThis custom Asset Editor shows a graph visualizing the Relationship Stages that can be progressed to from the Relationship Asset being viewed currently. I based it off of the Reference Viewer built into UE, and utilized custom EdGraph and EdGraphNode classes to build the progression Map. The editor also includes custom tools to walk designers through setting up complex Properties and a Context Panel that appears to help focus the information shown at once.\nRelationship Graph\r#\rI created the Graph to replace the experience of editing a static Details panel, and since each field on the Relationship Data Assets required heavy setup and often depended on other Properties or Assets, there were many places to implement custom flows to create a seamless experience as we built the Map. Interacting with the Graph would implicitly prompt designers to edit corresponding settings on the Relationship, and the Graph highlights relevant nodes, Properties, or errors in response. This editor helped us visualize and rapidly test different variations of Relationships and progression settings by making it simple to edit. The modular design of the Relationship system also supported this notion, and allowed us to create complex and engaging moments for our Players via these Relationships.\nSystem Design\nI utilized a View Model-driven approach, where the View Model serves as the central hub for all systematic logic connecting the Slate widget with game code and runtime data. The View Model acts as a mediator to ensure that the editor\u0026rsquo;s UI remains in sync with the game state while also managing communication with broader game systems and event handling.\nWith this setup:\nSRelationshipEditor::Construct(const FArguments\u0026amp; InArgs, TSharedPtr\u0026lt;FRelationshipEditorViewModel\u0026gt; InViewModel) { GraphObj = NewObject\u0026lt;UEdGraph_RelationshipEditor\u0026gt;(); GraphObj-\u0026gt;AddToRoot(); RelationshipEditorViewModel = InViewModel; ... GraphObj-\u0026gt;ConstructGraph(InViewModel); // Create the Graph Editor GraphEditorPtr = SNew(SGraphEditor) .GraphToEdit(GraphObj); ... // Add all other widgets } UEdGraph_RelationshipEditor::ConstructGraph() { // Use ViewModel information to determine which node is focused/should be centered UEdGraphNode_Relationship* CenterNode = SpawnNode(ViewModel, FVector2D(0.0f, 0.0f)); ... // Create graph ... ViewModel-\u0026gt;GraphEditor = this; }\rIt was then possible to retrieve the View Model from any relevant editor context to trigger or access data, like so:\nSRelationshipNode::OnMouseButtonDown(const FGeometry\u0026amp; Geometry, const FPointerEvent\u0026amp; MouseEvent) { UEdGraph_RelationshipEditor* Graph = GetGraph(); // If Graph and all relevant data is valid Graph-\u0026gt;GetEditorViewModel()-\u0026gt;HandleNodeSelected(GetNode()); }\rUsing a ViewModel to manage the connection between the editor\u0026rsquo;s Slate UI and game data cleanly decouples the UI from game logic. This modularity makes it easy for us to continue to iterate on the underlying Relationship system without worrying about maintaining the editor, since new features can be added without disrupting any other functionality.\nRelationship Editor Tools\r#\rI wanted it to be as easy as possible for designers to interact with and edit Relationships via the graph, so I also included tools within the editor to walk designers through setting up more complex Properties, like adding new Stages to progress to. Because this system was so complex as well, it was easy to create duplicates, forget to assign data to Properties, or make various other mistakes. This tool was also responsible for throwing errors should any information be inputted wrong to further expedite updating the Map.\nThis New Transition overlay was implemented as a standalone Tool that appeared as a popup when designers used a Button in the editor header linked to a custom UI command. This separate flow allowed designers to author each new progression stage as an explicit, state-driven process rather than ad hoc Property edits. This particular Tool consists of multiple steps that owns a narrowly scoped slice of data, so designers can set up these Transitions without leaving the workflow to hunt down related assets, contexts, or other dependencies elsewhere in the editor. Separating the process into sequential steps ensured that missing or conflicting data is identified and resolved at the point of entry, before it propogates into downstream systems and affecting other parts of the system - something that was incredibly important in such a fast-paced iteration environment.\nEmbedded Text Editor\r#\rAnother complication I had to solve working on this project was managing the amount of asynchronous processes that occured both at runtime and, more importantly here, during editor-time. These non-latent functions occasionally allowed designers to close the editor while processes were still running, which led to crashes or unsaved changes. I created a custom Property for all Assets that used the problematic interface that informed designers when their data was still processing, overrode the default Unreal Asset save behavior, and included a button to manually trigger the asynchronous process.\nTo prevent Assets from being saved in an incomplete state, I intercepted and modified the default save behavior on objects implementing the Embeddings interface so the Asset remained unsaved until all data has finished processing. When designers trigger a save, the asset is marked as dirty as non-latent processes are started and registered with an editor-only subsystem that tracks pending embedded Assets. Once all data is returned and proper delegates have been broadcasted, the Asset is marked clean, cleaned from the pending queue, and saved by the system. This prevents partial data from being serialized and written to disk and reduced the number of crashes caused during this workflow.\n","externalUrl":null,"permalink":"/games/burbank/slate-ui/","section":"Games","summary":"","title":"Slate Tooling","type":"games"},{"content":"Below are games that I have worked on professionally, academically, and personally. These are games in which I have created and owned systems that shipped with the final product and were instrumental in both production and deployment. All content featured is original work that I own and am authorized to share.\nSee below for showcases, technical design documents, system designs, and more.\n","date":"1 May 2025","externalUrl":null,"permalink":"/games/","section":"Games","summary":"","title":"Games","type":"games"},{"content":"","date":"1 May 2025","externalUrl":null,"permalink":"/","section":"Peyton Bischof","summary":"","title":"Peyton Bischof","type":"page"},{"content":"\rGameplay Engineer\r#\rProject Burbank is an unreleased life sim developed by a small team of industry veterans in Unreal Engine 5 at Midsummer Studios in Hunt Valley, MD. Burbank uniquely explores player connection with characters and storylines through life sim/visual novel sandbox-style gameplay. I am responsible for several core systems and have a hand in nearly every feature of the game.\nThis project was unique in its timeframe - we rapidly designed, engineered, and iterated on all systems and pipelines to meet tight demo deadlines. As a result, as well as creating gameplay mechanics in C++ and Blueprint, I also became fluent in Slate to customize our Editor and tooling to support our designers as we rapidly iterated on the games\u0026rsquo; development.\nDevelopment Log\r#\rDue to the small team size of 13, my skills were leveraged in a variety of ways to support all aspects of the game. Below are some of the major systems and features I contributed to Project Burbank:\n","date":"1 May 2025","externalUrl":null,"permalink":"/games/burbank/","section":"Games","summary":"","title":"Project Burbank","type":"games"},{"content":"\rCreative Director, Gameplay Programmer, Lead Technical Artist\r#\rInterweaver is an isometric puzzle-platformer built in Unity by a small team of students from the University of Central Florida as our Senior Design Capstone. I served as the Creative Director and was also responsible for programming a variety of major systems and mechanics in C# and created the majority of the visual effects in Unity\u0026rsquo;s Shader and VFX Graph.\nThis was my first experience leading a full development team of designers, artists, and programmers. I was at the forefront of production and development, and formed a leadership team that quickly became comfortable with Agile development strategies to create the best player experience during our 35-week production period.\nYou can find the Steam page here.\nDevelopment Log\r#\rI contributed heavily to this project from all aspects of production: code, art, and design. Below I will go into depth on major systems, features, and effects I am responsible for, as well as trying to explain some design decisions and philosophies that I learned during this experience.\n","date":"20 May 2024","externalUrl":null,"permalink":"/games/interweaver/","section":"Games","summary":"","title":"Interweaver","type":"games"},{"content":"","externalUrl":null,"permalink":"/contact/","section":"Peyton Bischof","summary":"","title":"About","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/resume/","section":"Peyton Bischof","summary":"","title":"Resume","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]